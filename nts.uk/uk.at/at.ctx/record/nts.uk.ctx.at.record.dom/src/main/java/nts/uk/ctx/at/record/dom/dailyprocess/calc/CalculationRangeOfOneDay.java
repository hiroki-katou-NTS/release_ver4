package nts.uk.ctx.at.record.dom.dailyprocess.calc;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import lombok.Getter;
import lombok.Setter;
import lombok.val;
import nts.gul.util.value.Finally;
import nts.uk.ctx.at.record.dom.actualworkinghours.SubHolOccurrenceInfo;
import nts.uk.ctx.at.record.dom.breakorgoout.BreakTimeOfDailyPerformance;
import nts.uk.ctx.at.record.dom.breakorgoout.OutingTimeOfDailyPerformance;
import nts.uk.ctx.at.record.dom.calculationattribute.BonusPayAutoCalcSet;
import nts.uk.ctx.at.record.dom.calculationattribute.CalAttrOfDailyPerformance;
import nts.uk.ctx.at.record.dom.calculationattribute.enums.AutoCalOverTimeAttr;
import nts.uk.ctx.at.record.dom.daily.ExcessOfStatutoryMidNightTime;
import nts.uk.ctx.at.record.dom.daily.ExcessOfStatutoryTimeOfDaily;
import nts.uk.ctx.at.record.dom.daily.TimeDivergenceWithCalculation;
import nts.uk.ctx.at.record.dom.daily.TimeWithCalculation;
import nts.uk.ctx.at.record.dom.daily.TimevacationUseTimeOfDaily;
import nts.uk.ctx.at.record.dom.daily.bonuspaytime.BonusPayTime;
import nts.uk.ctx.at.record.dom.daily.calcset.CalcMethodOfNoWorkingDay;
import nts.uk.ctx.at.record.dom.daily.holidayworktime.HolidayWorkFrameTimeSheet;
import nts.uk.ctx.at.record.dom.daily.midnight.MidNightTimeSheet;
import nts.uk.ctx.at.record.dom.dailyprocess.calc.withinstatutory.WithinPremiumTimeSheetForCalc;
import nts.uk.ctx.at.record.dom.dailyprocess.calc.withinstatutory.WithinWorkTimeFrame;
import nts.uk.ctx.at.record.dom.dailyprocess.calc.withinstatutory.WithinWorkTimeSheet;
import nts.uk.ctx.at.record.dom.raborstandardact.FlexCalcMethod;
import nts.uk.ctx.at.record.dom.raborstandardact.FlexCalcMethodOfEachPremiumHalfWork;
import nts.uk.ctx.at.record.dom.raborstandardact.FlexCalcMethodOfHalfWork;
import nts.uk.ctx.at.record.dom.raborstandardact.flex.SettingOfFlexWork;
import nts.uk.ctx.at.record.dom.raisesalarytime.RaiseSalaryTimeOfDailyPerfor;
import nts.uk.ctx.at.record.dom.raisesalarytime.RaisingSalaryTime;
import nts.uk.ctx.at.record.dom.workinformation.WorkInfoOfDailyPerformance;
import nts.uk.ctx.at.record.dom.worktime.TimeLeavingOfDailyPerformance;
import nts.uk.ctx.at.record.dom.worktime.primitivevalue.WorkTimes;
import nts.uk.ctx.at.shared.dom.bonuspay.setting.BonusPaySetting;
import nts.uk.ctx.at.shared.dom.calculation.holiday.HolidayAddtionSet;
import nts.uk.ctx.at.shared.dom.calculation.holiday.WorkDeformedLaborAdditionSet;
import nts.uk.ctx.at.shared.dom.calculation.holiday.WorkFlexAdditionSet;
import nts.uk.ctx.at.shared.dom.calculation.holiday.WorkRegularAdditionSet;
import nts.uk.ctx.at.shared.dom.calculation.holiday.kmk013_splitdomain.HolidayCalcMethodSet;
import nts.uk.ctx.at.shared.dom.common.DailyTime;
import nts.uk.ctx.at.shared.dom.common.time.AttendanceTime;
import nts.uk.ctx.at.shared.dom.common.time.TimeSpanForCalc;
import nts.uk.ctx.at.shared.dom.ot.autocalsetting.AutoCalOvertimeSetting;
import nts.uk.ctx.at.shared.dom.statutory.worktime.sharedNew.DailyUnit;
import nts.uk.ctx.at.shared.dom.workingcondition.WorkingSystem;
import nts.uk.ctx.at.shared.dom.workrule.outsideworktime.AutoCalRaisingSalarySetting;
import nts.uk.ctx.at.shared.dom.workrule.outsideworktime.OverDayEndCalcSet;
import nts.uk.ctx.at.shared.dom.workrule.outsideworktime.StatutoryAtr;
import nts.uk.ctx.at.shared.dom.workrule.outsideworktime.overtime.overtimeframe.OverTimeFrameNo;
import nts.uk.ctx.at.shared.dom.workrule.overtime.StatutoryPrioritySet;
import nts.uk.ctx.at.shared.dom.workrule.statutoryworktime.DailyCalculationPersonalInformation;
import nts.uk.ctx.at.shared.dom.workrule.waytowork.PersonalLaborCondition;
import nts.uk.ctx.at.shared.dom.worktime.common.CommonRestSetting;
import nts.uk.ctx.at.shared.dom.worktime.common.EmTimezoneNo;
import nts.uk.ctx.at.shared.dom.worktime.common.FixedRestCalculateMethod;
import nts.uk.ctx.at.shared.dom.worktime.common.HDWorkTimeSheetSetting;
import nts.uk.ctx.at.shared.dom.worktime.common.LegalOTSetting;
import nts.uk.ctx.at.shared.dom.worktime.common.OverTimeOfTimeZoneSet;
import nts.uk.ctx.at.shared.dom.worktime.common.RestClockManageAtr;
import nts.uk.ctx.at.shared.dom.worktime.common.TimeZoneRounding;
import nts.uk.ctx.at.shared.dom.worktime.common.WorkTimeCode;
import nts.uk.ctx.at.shared.dom.worktime.common.WorkTimezoneCommonSet;
import nts.uk.ctx.at.shared.dom.worktime.fixedset.FixedWorkSetting;
import nts.uk.ctx.at.shared.dom.worktime.flexset.CoreTimeSetting;
import nts.uk.ctx.at.shared.dom.worktime.flexset.FlexWorkSetting;
import nts.uk.ctx.at.shared.dom.worktime.flowset.FlowWorkRestSetting;
import nts.uk.ctx.at.shared.dom.worktime.flowset.FlowWorkRestTimezone;
import nts.uk.ctx.at.shared.dom.worktime.predset.BreakDownTimeDay;
import nts.uk.ctx.at.shared.dom.worktime.worktimeset.WorkTimeDailyAtr;
import nts.uk.ctx.at.shared.dom.worktime.worktimeset.WorkTimeDivision;
import nts.uk.ctx.at.shared.dom.worktime.worktimeset.WorkTimeMethodSet;
import nts.uk.ctx.at.shared.dom.worktime.worktimeset.WorkTimeSetting;
import nts.uk.ctx.at.shared.dom.worktype.WorkType;

/**
 * 1Êó•„ÅÆË®àÁÆóÁØ?õ≤
 * 
 * @author keisuke_hoshina
 *
 */
@Getter
public class CalculationRangeOfOneDay {

	private Finally<WithinWorkTimeSheet> withinWorkingTimeSheet = Finally.empty();

	@Setter
	private Finally<OutsideWorkTimeSheet> outsideWorkTimeSheet = Finally.empty();

	private TimeSpanForCalc oneDayOfRange;

	private WorkInfoOfDailyPerformance workInformationOfDaily;
	
	@Setter
	private TimeLeavingOfDailyPerformance attendanceLeavingWork;

	private PredetermineTimeSetForCalc predetermineTimeSetForCalc;

	private Finally<TimevacationUseTimeOfDaily> timeVacationAdditionRemainingTime = Finally.empty();// ÊôÇÈñì‰ºëÊöáÂä?ÁÆóÊÆãÊôÇÈñ?


	public CalculationRangeOfOneDay(Finally<WithinWorkTimeSheet> withinWorkingTimeSheet,
			Finally<OutsideWorkTimeSheet> outsideWorkTimeSheet, TimeSpanForCalc oneDayOfRange,
			TimeLeavingOfDailyPerformance attendanceLeavingWork, PredetermineTimeSetForCalc predetermineTimeSetForCalc,
			Finally<TimevacationUseTimeOfDaily> timeVacationAdditionRemainingTime,
			WorkInfoOfDailyPerformance workInformationofDaily) {
		this.withinWorkingTimeSheet = withinWorkingTimeSheet;
		this.outsideWorkTimeSheet = outsideWorkTimeSheet;
		this.oneDayOfRange = oneDayOfRange;
		this.attendanceLeavingWork = attendanceLeavingWork;
		this.predetermineTimeSetForCalc = predetermineTimeSetForCalc;
		this.timeVacationAdditionRemainingTime = timeVacationAdditionRemainingTime;
		this.workInformationOfDaily = workInformationofDaily;
	}

	/**
	 * Â∞±Ê•≠ÊôÇÈñìÂ∏Ø„ÅÆ‰ΩúÊ?
	 * 
	 * @param workingSystem
	 * @param setMethod
	 * @param clockManage
	 * @param dailyGoOutSheet
	 * @param CommonSet
	 * @param fixedCalc
	 * @param workTimeDivision
	 * @param noStampSet
	 * @param fluidSet
	 * @param breakmanage
	 * @param workTimeMethodSet
	 * @param fluRestTime
	 * @param fluidprefixBreakTimeSet
	 * @param predetermineTimeSet
	 * @param fixedWorkSetting
	 * @param workTimeCommonSet
	 * @param bonusPaySetting
	 * @param overTimeHourSetList
	 * @param fixOff
	 * @param dayEndSet
	 * @param overDayEndSet
	 * @param holidayTimeWorkItem
	 * @param beforeDay
	 *            ÂâçÊó•„ÅÆÂã§ÂãôÁ®ÆÈ°?
	 * @param toDay
	 *            ÂΩìÊó•„ÅÆÂã§ÂãôÁ®ÆÈ°?
	 * @param afterDay
	 *            ÁøåÊó•„ÅÆÂã§ÂãôÁ®ÆÈ°?
	 * @param breakdownTimeDay
	 * @param dailyTime
	 *            Ê≥ïÂÆöÂä¥ÂÉçÊôÇÈñ?
	 * @param calcSetinIntegre
	 * @param statutorySet
	 * @param prioritySet
	 * @param integrationOfDaily 
	 */
	public void createWithinWorkTimeSheet(WorkingSystem workingSystem, WorkTimeMethodSet setMethod,
			RestClockManageAtr clockManage, OutingTimeOfDailyPerformance dailyGoOutSheet, CommonRestSetting commonSet,
			Optional<FixedRestCalculateMethod> fixedCalc, WorkTimeDivision workTimeDivision, 
			PredetermineTimeSetForCalc predetermineTimeSetForCalc,
			FixedWorkSetting fixedWorkSetting, BonusPaySetting bonusPaySetting,
			List<OverTimeOfTimeZoneSet> overTimeHourSetList, List<HDWorkTimeSheetSetting> fixOff, OverDayEndCalcSet dayEndSet,
			List<HolidayWorkFrameTimeSheet> holidayTimeWorkItem, WorkType beforeDay, WorkType toDay, WorkType afterDay,
			BreakDownTimeDay breakdownTimeDay, DailyTime dailyTime, CalAttrOfDailyPerformance calcSetinIntegre,
			LegalOTSetting statutorySet, StatutoryPrioritySet prioritySet, WorkTimeSetting workTime,List<BreakTimeOfDailyPerformance> breakTimeOfDailyList
			,MidNightTimeSheet midNightTimeSheet,DailyCalculationPersonalInformation personalInfo,Optional<CoreTimeSetting> coreTimeSetting,
			HolidayCalcMethodSet holidayCalcMethodSet,DailyUnit dailyUnit,List<TimeSheetOfDeductionItem> breakTimeList,
    		VacationClass vacationClass, TimevacationUseTimeOfDaily timevacationUseTimeOfDaily,
    		Optional<WorkTimeCode> siftCode, Optional<PersonalLaborCondition> personalCondition, 
    		boolean late, boolean leaveEarly, WorkDeformedLaborAdditionSet illegularAddSetting, WorkFlexAdditionSet flexAddSetting, 
    		WorkRegularAdditionSet regularAddSetting, HolidayAddtionSet holidayAddtionSet) {
		/* Âõ∫ÂÆöÊéßÈô§ÊôÇÈñìÂ∏Ø„ÅÆ‰ΩúÊ? */
		DeductionTimeSheet deductionTimeSheet = DeductionTimeSheet.createTimeSheetForFixBreakTime(
				setMethod, clockManage, dailyGoOutSheet, this.oneDayOfRange, commonSet, attendanceLeavingWork,
				fixedCalc, workTimeDivision, breakTimeOfDailyList);
		
		val fixedWorkTImeZoneSet = new CommonFixedWorkTimezoneSet();
		fixedWorkTImeZoneSet.forFixed(fixedWorkSetting.getLstHalfDayWorkTimezone());
		theDayOfWorkTimesLoop(workingSystem, predetermineTimeSetForCalc, fixedWorkTImeZoneSet,fixedWorkSetting.getCommonSetting(), bonusPaySetting,
				overTimeHourSetList, fixOff, dayEndSet, holidayTimeWorkItem, beforeDay, toDay, afterDay,
				breakdownTimeDay, dailyTime, calcSetinIntegre, statutorySet, prioritySet, deductionTimeSheet,
				workTime,midNightTimeSheet,personalInfo,holidayCalcMethodSet,coreTimeSetting,dailyUnit,breakTimeList, 
				vacationClass, timevacationUseTimeOfDaily,  
				siftCode, personalCondition, leaveEarly, leaveEarly, illegularAddSetting, 
				flexAddSetting, regularAddSetting, holidayAddtionSet);
	}

	/**
	 * ÊôÇÈñìÂ∏Ø‰ΩúÊ?(Âã§ÂãôÂõûÊï∞Âà??„É´„Éº„É?) Â∞±Ê•≠ÊôÇÈñìÂÜ??Â§ñ„?Âá¶Áê?
	 * 
	 * @param workingSystem
	 *            Âä¥ÂÉçÂà∂„ÇØ„É©„Çπ
	 * @param predetermineTimeSet
	 *            Êâ?ÂÆöÊôÇÈñìË®≠ÂÆö„ÇØ„É©„Çπ
	 * @param fixedWorkSetting
	 *            Âõ∫ÂÆöÂã§ÂãôË®≠ÂÆö„ÇØ„É©„Çπ
	 * @param workTimeCommonSet
	 *            Â∞±Ê•≠ÊôÇÈñìÂ∏Ø„ÅÆÂÖ±ÈÄöË®≠ÂÆö„ÇØ„É©„Çπ
	 * @param bonusPaySetting
	 *            Âä?Áµ¶Ë®≠ÂÆö„ÇØ„É©„Çπ
	 * @param overTimeHourSetList
	 *            ÊÆãÊ•≠ÊôÇÈñì„ÅÆÊôÇÈñìÂ∏ØË®≠ÂÆö„ÇØ„É©„Çπ
	 * @param fixOff
	 *            Âõ∫ÂÆöÂã§Âãô„?‰ºëÊó•Âá∫Âã§Áî®Âã§ÂãôÊôÇÈñìÂ∏Ø„ÇØ„É©„Çπ
	 * @param dayEndSet
	 *            0ÊôÇË∑®„ÅéË®àÁÆóË®≠ÂÆö„ÇØ„É©„Çπ
	 * @param overDayEndSet
	 *            Â∞±Ê•≠ÊôÇÈñìÂ∏Ø„ÅÆÂÖ±ÈÄöË®≠ÂÆö„ÇØ„É©„Çπ
	 * @param holidayTimeWorkItem
	 *            ‰ºëÂ?Êû?ÊôÇÈñìÂ∏Ø
	 * @param beforeDay
	 *            Âã§ÂãôÁ®ÆÈ°û„ÇØ„É©„Çπ
	 * @param toDay
	 *            Âã§ÂãôÁ®ÆÈ°û„ÇØ„É©„Çπ
	 * @param afterDay
	 *            Âã§ÂãôÁ®ÆÈ°û„ÇØ„É©„Çπ
	 * @param breakdownTimeDay
	 *            1Êó•„ÅÆÊôÇÈñìÂÜ?®≥„ÇØ„É©„Çπ
	 * @param dailyTime
	 *            Ê≥ïÂÆöÂä¥ÂÉçÊôÇÈñ?
	 * @param calcSetinIntegre
	 *            ÊÆãÊ•≠ÊôÇÈñì„ÅÆËá™ÂãïË®àÁÆóË®≠ÂÆö„ÇØ„É©„Çπ
	 * @param statutorySet
	 *            Ê≥ïÂÆöÂ?ÊÆãÊ•≠Ë®≠ÂÆ?
	 * @param prioritySet
	 *            Ê≥ïÂÆöÂ?ÂÑ™ÂÖàË®≠ÂÆ?
	 * @param deductionTimeSheet
	 *            ÊéßÈô§ÊôÇÈñìÂ∏Ø
	 * @param integrationOfDaily 
	 */
	public void theDayOfWorkTimesLoop(WorkingSystem workingSystem, PredetermineTimeSetForCalc predetermineTimeSetForCalc,
			CommonFixedWorkTimezoneSet lstHalfDayWorkTimezone,
			WorkTimezoneCommonSet workTimeCommonSet, BonusPaySetting bonusPaySetting,
			List<OverTimeOfTimeZoneSet> overTimeHourSetList, List<HDWorkTimeSheetSetting> fixOff, OverDayEndCalcSet dayEndSet,
			List<HolidayWorkFrameTimeSheet> holidayTimeWorkItem, WorkType beforeDay, WorkType toDay, WorkType afterDay,
			BreakDownTimeDay breakdownTimeDay, DailyTime dailyTime, CalAttrOfDailyPerformance calcSetinIntegre,
			LegalOTSetting statutorySet, StatutoryPrioritySet prioritySet,
			DeductionTimeSheet deductionTimeSheet, WorkTimeSetting workTime,MidNightTimeSheet midNightTimeSheet,
			DailyCalculationPersonalInformation personalInfo,HolidayCalcMethodSet holidayCalcMethodSet,
			Optional<CoreTimeSetting> coreTimeSetting,DailyUnit dailyUnit,List<TimeSheetOfDeductionItem> breakTimeList,
    		VacationClass vacationClass, TimevacationUseTimeOfDaily timevacationUseTimeOfDaily, 
    		Optional<WorkTimeCode> siftCode, Optional<PersonalLaborCondition> personalCondition, 
    		boolean late, boolean leaveEarly, WorkDeformedLaborAdditionSet illegularAddSetting, WorkFlexAdditionSet flexAddSetting, 
    		WorkRegularAdditionSet regularAddSetting, HolidayAddtionSet holidayAddtionSet) {
		if (workingSystem.isExcludedWorkingCalculate()) {
			/* Ë®àÁÆóÂØæË±°Â§ñ„?Âá¶Áê? */
			return;
		}
		for (int workNumber = 1; workNumber <= attendanceLeavingWork.getTimeLeavingWorks().size(); workNumber++) {
			
			/* Â∞±Ê•≠ÂÜ??ÊôÇÈñìÂ∏Ø‰ΩúÊ? */
			//ÊâìÂàª„ÅØ„ÅÇ„ÇãÂâçÊèê„ÅßÂãï„Åè
			val createWithinWorkTimeSheet = WithinWorkTimeSheet.createAsFixed(attendanceLeavingWork.getAttendanceLeavingWork(new nts.uk.ctx.at.shared.dom.worktime.common.WorkNo(workNumber)).get(),
																			  toDay,
																			  predetermineTimeSetForCalc, 
																			  lstHalfDayWorkTimezone,
																			  workTimeCommonSet,
																			  deductionTimeSheet,
																			  bonusPaySetting,
																			  midNightTimeSheet,
																			  workNumber,
																			  coreTimeSetting,
																			  holidayCalcMethodSet,
																			  workTimeCommonSet.getLateEarlySet(),
																			  dailyUnit,breakTimeList,
																			  personalCondition, 
																			  vacationClass, 
																			  late, 
																				leaveEarly, 
																				workingSystem, 
																				illegularAddSetting, 
																				flexAddSetting, 
																				regularAddSetting, 
																				holidayAddtionSet, 
																				CalcMethodOfNoWorkingDay.isCalculateFlexTime, 
																				AutoCalOverTimeAttr.CALCULATION_FROM_STAMP, 
																				Optional.of(new SettingOfFlexWork(new FlexCalcMethodOfHalfWork(new FlexCalcMethodOfEachPremiumHalfWork(FlexCalcMethod.OneDay, FlexCalcMethod.OneDay),
																						                                                       new FlexCalcMethodOfEachPremiumHalfWork(FlexCalcMethod.OneDay, FlexCalcMethod.OneDay)))), 
																				workTime.getWorkTimeDivision().getWorkTimeDailyAtr(), 
																				siftCode, 
																				new AttendanceTime(1440), 
																				Finally.of(timevacationUseTimeOfDaily));
			if(withinWorkingTimeSheet.isPresent()) {
				withinWorkingTimeSheet.get().getWithinWorkTimeFrame().addAll(createWithinWorkTimeSheet.getWithinWorkTimeFrame());
			}
			else {
				withinWorkingTimeSheet.set(createWithinWorkTimeSheet);
			}
			/* Â∞±Ê•≠Â§ñ„?ÊôÇÈñìÂ∏Ø‰ΩúÊ? */
			//ÊâìÂàª„ÅØ„ÅÇ„ÇãÂâçÊèê„ÅßÂãï„Åè
			val createOutSideWorkTimeSheet = OutsideWorkTimeSheet.createOutsideWorkTimeSheet(overTimeHourSetList, fixOff,
					attendanceLeavingWork.getAttendanceLeavingWork(new nts.uk.ctx.at.shared.dom.worktime.common.WorkNo(workNumber)).get(),
					workNumber, dayEndSet, workTimeCommonSet, holidayTimeWorkItem, beforeDay, toDay, afterDay, workTime,
					workingSystem, breakdownTimeDay, dailyTime, calcSetinIntegre.getOvertimeSetting(), statutorySet, prioritySet
					,bonusPaySetting,midNightTimeSheet,personalInfo,deductionTimeSheet,dailyUnit,holidayCalcMethodSet,createWithinWorkTimeSheet, 
					vacationClass, timevacationUseTimeOfDaily, predetermineTimeSetForCalc, 
					siftCode, personalCondition, leaveEarly, leaveEarly, illegularAddSetting, flexAddSetting, regularAddSetting, holidayAddtionSet
					);
			if(!outsideWorkTimeSheet.isPresent()) {
				//outsideWorkTimeSheet.set(createOutSideWorkTimeSheet);
				this.outsideWorkTimeSheet = Finally.of(createOutSideWorkTimeSheet);
			}
			else {
				//ÊÆãÊ•≠
				if(outsideWorkTimeSheet.get().getOverTimeWorkSheet().isPresent()) {
					List<OverTimeFrameTimeSheetForCalc> addOverList = createOutSideWorkTimeSheet.getOverTimeWorkSheet().isPresent()? createOutSideWorkTimeSheet.getOverTimeWorkSheet().get().getFrameTimeSheets():Collections.emptyList();
					outsideWorkTimeSheet.get().getOverTimeWorkSheet().get().getFrameTimeSheets().addAll(addOverList);
				}
				else {
					this.outsideWorkTimeSheet = Finally.of(new OutsideWorkTimeSheet(createOutSideWorkTimeSheet.getOverTimeWorkSheet(),this.outsideWorkTimeSheet.get().getHolidayWorkTimeSheet()));
				}
				//‰ºëÂ?
				if(outsideWorkTimeSheet.get().getHolidayWorkTimeSheet().isPresent()) {
					List<HolidayWorkFrameTimeSheetForCalc> addHolList = createOutSideWorkTimeSheet.getHolidayWorkTimeSheet().isPresent()? createOutSideWorkTimeSheet.getHolidayWorkTimeSheet().get().getWorkHolidayTime():Collections.emptyList();
					outsideWorkTimeSheet.get().getHolidayWorkTimeSheet().get().getWorkHolidayTime().addAll(addHolList);
				}
				else {
					this.outsideWorkTimeSheet = Finally.of(new OutsideWorkTimeSheet(this.outsideWorkTimeSheet.get().getOverTimeWorkSheet(),createOutSideWorkTimeSheet.getHolidayWorkTimeSheet()));
				}
			}
		}
		List<OverTimeFrameTimeSheetForCalc> paramList = new ArrayList<>();
		if(this.outsideWorkTimeSheet.isPresent()
			&& this.outsideWorkTimeSheet.get().getOverTimeWorkSheet().isPresent()) {
			paramList = this.outsideWorkTimeSheet.get().getOverTimeWorkSheet().get().getFrameTimeSheets();
		}
		val overTimeFrame = forOOtsukaPartMethod(statutorySet, 
							 dailyTime,
							 paramList,
							 calcSetinIntegre.getOvertimeSetting(),
							 breakdownTimeDay,
							 overTimeHourSetList,
							 dailyUnit,
							 holidayCalcMethodSet,
							 vacationClass,
							 timevacationUseTimeOfDaily,
							 afterDay,
							 predetermineTimeSetForCalc,
							 siftCode,
							 personalCondition,
							 leaveEarly,
							 workingSystem,
							 holidayAddtionSet,
							 regularAddSetting,
							 flexAddSetting,
							 illegularAddSetting,
							 leaveEarly);
		if(!overTimeFrame.isEmpty()) {
			if(outsideWorkTimeSheet.isPresent()) {
				if(outsideWorkTimeSheet.get().getOverTimeWorkSheet().isPresent()) {
					outsideWorkTimeSheet.get().getOverTimeWorkSheet().get().getFrameTimeSheets().addAll(overTimeFrame);
					return;
				}
				//ÊÆãÊ•≠ËøΩÂä?
				else {
					this.outsideWorkTimeSheet = Finally.of(new OutsideWorkTimeSheet(Optional.of(new OverTimeSheet(new RaisingSalaryTime(),
						  																					  	  overTimeFrame,
						  																					  	  new SubHolOccurrenceInfo()
																					)),
												this.outsideWorkTimeSheet.get().getHolidayWorkTimeSheet()
												));
				}
			}
			//Êâ?ÂÆöÂ§ñ„Ç§„É≥„Çπ„Çø„É≥„Çπ‰ΩúÊ?
			else {
				this.outsideWorkTimeSheet = Finally.of(new OutsideWorkTimeSheet(Optional.of(new OverTimeSheet(new RaisingSalaryTime(),
																										  overTimeFrame,
																										  new SubHolOccurrenceInfo()
							   						 						)),
					   														Optional.of(new HolidayWorkTimeSheet(new RaisingSalaryTime(),
					   																							 Collections.emptyList(), 
					   																							 new SubHolOccurrenceInfo()))
					   														));
			}
		}		
	}

	
	/**
	 * Â§ßÂ°ö„??Âõ∫ÂÆöÂã§Âãô„?ÊµÅÂãïÊÆãÊ•≠ÂØæÂø?(Êâ?ÂÆöÂ?Ââ≤Â¢ó„ÇíÊÆãÊ•≠ÊôÇÈñìÂ∏Ø„Å∏Áßª„Å?)
	 * @param statutorySet
	 * @param dailyTime
	 * @param overTimeWorkFrameTimeSheetList
	 * @param autoCalculationSet
	 * @param breakdownTimeDay
	 * @param overTimeHourSetList
	 * @param dailyUnit
	 * @param holidayCalcMethodSet
	 * @param vacationClass
	 * @param timevacationUseTimeOfDaily
	 * @param workType
	 * @param predetermineTimeSet
	 * @param siftCode
	 * @param personalCondition
	 * @param late
	 * @param workingSystem
	 * @param holidayAddtionSet
	 * @param regularAddSetting
	 * @param flexAddSetting
	 * @param illegularAddSetting
	 * @param leaveEarly
	 * @return
	 */
	private List<OverTimeFrameTimeSheetForCalc> forOOtsukaPartMethod(LegalOTSetting statutorySet, DailyTime dailyTime, List<OverTimeFrameTimeSheetForCalc> overTimeWorkFrameTimeSheetList, 
									  AutoCalOvertimeSetting autoCalculationSet, BreakDownTimeDay breakdownTimeDay, List<OverTimeOfTimeZoneSet> overTimeHourSetList, 
									  DailyUnit dailyUnit, HolidayCalcMethodSet holidayCalcMethodSet,
									  VacationClass vacationClass, TimevacationUseTimeOfDaily timevacationUseTimeOfDaily, WorkType workType, 
									  PredetermineTimeSetForCalc predetermineTimeSet, Optional<WorkTimeCode> siftCode, Optional<PersonalLaborCondition> personalCondition, 
									  boolean late, WorkingSystem workingSystem, HolidayAddtionSet holidayAddtionSet, WorkRegularAdditionSet regularAddSetting, 
									  WorkFlexAdditionSet flexAddSetting, WorkDeformedLaborAdditionSet illegularAddSetting, boolean leaveEarly) {
		
		if(!this.withinWorkingTimeSheet.isPresent())
			return Collections.emptyList();
		List<WithinWorkTimeFrame> renewWithinFrame = new ArrayList<>();
		List<OverTimeFrameTimeSheetForCalc> returnList = new ArrayList<>();
		//Êâ?ÂÆöÂ?Â∞±Ê•≠ÊôÇÈñìÊû?„ÅÆ„É´„Éº„É?
		for(WithinWorkTimeFrame timeSheet : this.withinWorkingTimeSheet.get().getWithinWorkTimeFrame()) {
			//Ââ≤Â¢óÊôÇÈñìÂ∏Ø„Åå‰ΩúÊ?„Åï„Çå„Å¶„Å?Çã„ÅãÁ¢∫Ë™?
			if(timeSheet.getPremiumTimeSheetInPredetermined().isPresent()) {
				
					val newTimeSpan = timeSheet.timeSheet.getTimeSpan().getNotDuplicationWith(timeSheet.getPremiumTimeSheetInPredetermined().get().getTimeSheet());
					//Â∞±Ê•≠ÊôÇÈñìÊû?ÊôÇÈñìÂ∏Ø„Å®Ââ≤Â¢óÊôÇÈñìÂ∏Ø„ÅÆÈáç„Å™„Å£„Å¶„Å?Å™„Å?É®Âà?Åß„Ä?
					//Â∞±Ê•≠ÊôÇÈñìÊû?ÊôÇÈñìÂ∏Ø„Çí‰Ωú„ÇäÁõ¥„Å?
					if(newTimeSpan.isPresent()) {
						renewWithinFrame.add(new WithinWorkTimeFrame(timeSheet.getWorkingHoursTimeNo(),
																	 new TimeZoneRounding(newTimeSpan.get().getStart(),newTimeSpan.get().getEnd(),timeSheet.getTimeSheet().getRounding()),
																	 newTimeSpan.get().getSpan(),
																	 timeSheet.duplicateNewTimeSpan(newTimeSpan.get()),
																	 timeSheet.duplicateNewTimeSpan(newTimeSpan.get()),
																	 timeSheet.getDuplicatedBonusPayNotStatic(timeSheet.getBonusPayTimeSheet(), newTimeSpan.get()),//Âä?Áµ¶
																	 timeSheet.getMidNightTimeSheet().isPresent()
																	 	?timeSheet.getDuplicateMidNightNotStatic(timeSheet.getMidNightTimeSheet().get(),newTimeSpan.get())
																	 	:Optional.empty(),//Ê∑±Â§?
																	 timeSheet.getDuplicatedSpecBonusPayzNotStatic(timeSheet.getSpecBonusPayTimesheet(), newTimeSpan.get()),//ÁâπÂÆöÊó•Âä?Áµ¶
																	 timeSheet.getLateTimeSheet(),
																	 timeSheet.getLeaveEarlyTimeSheet()
											 ));
						
					}
					
					returnList.add(new OverTimeFrameTimeSheetForCalc(new TimeZoneRounding(timeSheet.getPremiumTimeSheetInPredetermined().get().getTimeSheet().getStart(),timeSheet.getPremiumTimeSheetInPredetermined().get().getTimeSheet().getEnd(),null),
																						timeSheet.getPremiumTimeSheetInPredetermined().get().getTimeSheet(),
													  								 Collections.emptyList(),
													  								 Collections.emptyList(),
													  								 Collections.emptyList(),
													  								 Collections.emptyList(),
													  								 Optional.empty(),
													  								 new OverTimeFrameTime(new OverTimeFrameNo(10),
													  										 			   TimeDivergenceWithCalculation.sameTime(new AttendanceTime(0)),
													  										 			   TimeDivergenceWithCalculation.sameTime(new AttendanceTime(0)),
													  										 			   new AttendanceTime(0),
													  										 			   new AttendanceTime(0)),
													  								 StatutoryAtr.Excess,
													  								 false,
													  								 new EmTimezoneNo(0),
													  								 false,
													  								 Optional.empty(),
													  								 Optional.empty()
													  								 ));
				
			}
		}
		//Êâ?ÂÆöÂ?Ââ≤Â¢óÊôÇÈñìÂ?ÊúüÂåñ
		if(this.withinWorkingTimeSheet.isPresent()) {
			this.withinWorkingTimeSheet.get().resetPremiumTimeSheet();
		}
		if(!renewWithinFrame.isEmpty()) {
			this.withinWorkingTimeSheet.get().getWithinWorkTimeFrame().clear();
			this.withinWorkingTimeSheet.get().getWithinWorkTimeFrame().addAll(renewWithinFrame);
		}
		return OverTimeFrameTimeSheetForCalc.diciaionCalcStatutory(statutorySet, 
															dailyTime, 
															returnList, 
															autoCalculationSet, 
															breakdownTimeDay, 
															overTimeHourSetList, 
															dailyUnit, 
															holidayCalcMethodSet, 
															withinWorkingTimeSheet.get(), 
															vacationClass, 
															timevacationUseTimeOfDaily, 
															workType, 
															predetermineTimeSet, 
															siftCode, 
															personalCondition, 
															late, 
															leaveEarly, 
															workingSystem, 
															illegularAddSetting, 
															flexAddSetting, 
															regularAddSetting, 
															holidayAddtionSet);
	}

	/**
	 * Âê?∑±Â§úÊôÇÈñì„?ÁÆóÂ?ÁµêÊûú„Åã„ÇâÊ∑±Â§úÊôÇÈñì„?ÂêàË®à„ÇíÁÆóÂ?„Åô„Çã
	 * 
	 * @return Ê∑±Â§úÊôÇÈñ?
	 */
	public ExcessOfStatutoryTimeOfDaily calcMidNightTime(ExcessOfStatutoryTimeOfDaily excessOfDaily) {
		// ExcessOverTimeWorkMidNightTime excessHolidayWorkMidNight =
		// excessOfDaily.getOverTimeWork().get().calcMidNightTimeIncludeOverTimeWork();
		// HolidayMidnightWork excessMidNight =
		// excessOfDaily.getWorkHolidayTime().get().calcMidNightTimeIncludeHolidayWorkTime(autoCalcSet);
		int beforeTime = 0;
		int totalTime = 0/* ÊÆãÊ•≠Ê∑±Â§ú„Å®‰ºëÂ?Ê∑±Â§ú„?ÂêàË®àÁÆóÂ? */;
		excessOfDaily.setExcessOfStatutoryMidNightTime(
				new ExcessOfStatutoryMidNightTime(TimeDivergenceWithCalculation.sameTime(new AttendanceTime(totalTime)), new AttendanceTime(beforeTime)));
		return excessOfDaily;
	}

	/**
	 * Â∞±ÂÜ??ÊÆãÊ•≠ÂÜ??‰ºëÂ?ÊôÇÈñìÂÜ??Âä?Áµ¶ÊôÇÈñì„ÅÆÂêàË®à„ÇíÊ±Ç„ÇÅ„Ç?
	 */
	public List<BonusPayTime> calcBonusPayTime(AutoCalRaisingSalarySetting raisingAutoCalcSet,BonusPayAutoCalcSet bonusPayAutoCalcSet,
											   CalAttrOfDailyPerformance calcAtrOfDaily, BonusPayAtr bonusPayAtr) {
		
		List<BonusPayTime> overTimeBonusPay = new ArrayList<>();
		List<BonusPayTime> holidayWorkBonusPay = new ArrayList<>();
		List<BonusPayTime> withinBonusPay = new ArrayList<>();
		if(withinWorkingTimeSheet.isPresent())
			withinBonusPay = withinWorkingTimeSheet.get().calcBonusPayTimeInWithinWorkTime(raisingAutoCalcSet,bonusPayAutoCalcSet, bonusPayAtr,calcAtrOfDaily);
		
		if(outsideWorkTimeSheet.isPresent())
		{
			if(outsideWorkTimeSheet.get().getOverTimeWorkSheet().isPresent()) { 
				overTimeBonusPay = outsideWorkTimeSheet.get().getOverTimeWorkSheet().get().calcBonusPayTimeInOverWorkTime(raisingAutoCalcSet, bonusPayAutoCalcSet, bonusPayAtr, calcAtrOfDaily);
			}
			
			if(outsideWorkTimeSheet.get().getHolidayWorkTimeSheet().isPresent()) {
				holidayWorkBonusPay = outsideWorkTimeSheet.get().getHolidayWorkTimeSheet().get().calcBonusPayTimeInHolidayWorkTime(raisingAutoCalcSet, bonusPayAutoCalcSet, bonusPayAtr, calcAtrOfDaily);
			}
		}
		return calcBonusPayTime(withinBonusPay,overTimeBonusPay,holidayWorkBonusPay);
	}
	
	/**
	 * Â∞±ÂÜ??ÊÆãÊ•≠ÂÜ??‰ºëÂ?ÊôÇÈñìÂÜ??ÁâπÂÆöÂä†Áµ¶ÊôÇÈñì„ÅÆÂêàË®à„ÇíÊ±Ç„ÇÅ„Ç?
	 */
	public List<BonusPayTime> calcSpecBonusPayTime(AutoCalRaisingSalarySetting raisingAutoCalcSet,BonusPayAutoCalcSet bonusPayAutoCalcSet,
												   CalAttrOfDailyPerformance calcAtrOfDaily,BonusPayAtr bonusPayAtr){
		List<BonusPayTime> overTimeBonusPay = new ArrayList<>();
		List<BonusPayTime> holidayWorkBonusPay = new ArrayList<>();
		List<BonusPayTime> withinBonusPay = new ArrayList<>();
		
		if(withinWorkingTimeSheet.isPresent())
				withinWorkingTimeSheet.get().calcSpecifiedBonusPayTimeInWithinWorkTime(raisingAutoCalcSet,bonusPayAutoCalcSet, bonusPayAtr,calcAtrOfDaily);

		if(outsideWorkTimeSheet.isPresent())
		{
			if(outsideWorkTimeSheet.get().getOverTimeWorkSheet().isPresent()) { 
				overTimeBonusPay = outsideWorkTimeSheet.get().getOverTimeWorkSheet().get().calcSpecBonusPayTimeInOverWorkTime(raisingAutoCalcSet, bonusPayAutoCalcSet, bonusPayAtr, calcAtrOfDaily);
			}
			
			if(outsideWorkTimeSheet.get().getHolidayWorkTimeSheet().isPresent()) {
				holidayWorkBonusPay = outsideWorkTimeSheet.get().getHolidayWorkTimeSheet().get().calcSpecBonusPayTimeInHolidayWorkTime(raisingAutoCalcSet, bonusPayAutoCalcSet, bonusPayAtr, calcAtrOfDaily);
			}
		}
		return calcBonusPayTime(withinBonusPay,overTimeBonusPay,holidayWorkBonusPay);
	}
	
	/**
	 * Â∞±„ÉªÊÆã„?‰ºë„?Âä?Áµ¶ÊôÇÈñì„ÇíÂêàË®à„Åô„Ç?
	 * @param withinBonusPay
	 * @param overTimeBonusPay
	 * @param holidayWorkBonusPay
	 * @return„Ä?ÂêàË®àÂæå„?Âä?ÁÆóÊôÇÈñ?(No„Åß„É¶„Éã„?„ÇØ)
	 */
	private List<BonusPayTime> calcBonusPayTime(List<BonusPayTime> withinBonusPay ,
								   List<BonusPayTime> overTimeBonusPay ,
								   List<BonusPayTime> holidayWorkBonusPay){
		List<BonusPayTime> returnList = new ArrayList<>();
		
		overTimeBonusPay.addAll(holidayWorkBonusPay);
		val excessPayTime = overTimeBonusPay;
		for(int bonusPayNo = 1 ; bonusPayNo <= 10 ; bonusPayNo++) {
			returnList.add(addWithinAndExcessBonusTime(sumBonusPayTime(getByBonusPayNo(withinBonusPay,bonusPayNo),bonusPayNo),
													   sumBonusPayTime(getByBonusPayNo(excessPayTime,bonusPayNo),bonusPayNo)
													   ,bonusPayNo));
		}
		return returnList;
	}
	
	/**
	 * Âèó„ÅëÂèñ„Å£„Å?2„Å§„ÅÆÂä?Áµ¶ÊôÇÈñì„ÅåÊåÅ„Å§ÊôÇÈñì„ÇíÂêàÁÆ?
	 * @param within
	 * @param excess
	 * @param bonusPayNo
	 * @return
	 */
	private BonusPayTime addWithinAndExcessBonusTime(BonusPayTime within,BonusPayTime excess,int bonusPayNo) {
		return new BonusPayTime(bonusPayNo,
								within.getBonusPayTime().addMinutes(excess.getBonusPayTime().valueAsMinutes()),
								within.getWithinBonusPay().addMinutes(excess.getWithinBonusPay().getTime(), 
																	  excess.getWithinBonusPay().getCalcTime()),
								within.getExcessBonusPayTime().addMinutes(excess.getExcessBonusPayTime().getTime(), 
										  								  excess.getExcessBonusPayTime().getCalcTime())
								);
	}
	
	/**
	 * Âê?ôÇÈñì„?ÂêàË®à„ÇíÁÆóÂ?
	 * @param bonusPayList„Ä?Âä?Áµ¶ÊôÇÈñì„ÅÆ„É™„Çπ„É?
	 * @param bonusPayNo„Ä?Âä?Áµ¶ÊôÇÈñì?Æ??
	 * @return„Ä?ÂêàË®àÊôÇÈñì„?Âä?Áµ¶ÊôÇÈñì
	 */
	private BonusPayTime sumBonusPayTime(List<BonusPayTime> bonusPayList, int bonusPayNo) {
		AttendanceTime bonusPayTime =  new AttendanceTime(bonusPayList.stream().map(tc -> tc.getBonusPayTime().valueAsMinutes()).collect(Collectors.summingInt(tc -> tc)));
		AttendanceTime withinTime = new AttendanceTime(bonusPayList.stream().map(tc -> tc.getWithinBonusPay().getTime().valueAsMinutes()).collect(Collectors.summingInt(tc -> tc)));
		AttendanceTime withinCalcTime = new AttendanceTime(bonusPayList.stream().map(tc -> tc.getWithinBonusPay().getCalcTime().valueAsMinutes()).collect(Collectors.summingInt(tc -> tc)));
		AttendanceTime excessTime = new AttendanceTime(bonusPayList.stream().map(tc -> tc.getExcessBonusPayTime().getTime().valueAsMinutes()).collect(Collectors.summingInt(tc -> tc)));
		AttendanceTime excessCalcTime = new AttendanceTime(bonusPayList.stream().map(tc -> tc.getExcessBonusPayTime().getCalcTime().valueAsMinutes()).collect(Collectors.summingInt(tc -> tc)));
		
		return new BonusPayTime(bonusPayNo,
								bonusPayTime,
								TimeWithCalculation.createTimeWithCalculation(withinTime, withinCalcTime),
								TimeWithCalculation.createTimeWithCalculation(excessTime, excessCalcTime));
	}
	
	/**
	 * Âèó„ÅëÂèñ„Å£„ÅüÂä†Áµ¶ÊôÇÈñì?Æ?è„ÇíÊåÅ„Å§Âä?Áµ¶ÊôÇÈñì„ÇíÂèñÂæ?
	 * @param bonusPayTime Âä?Áµ¶ÊôÇÈñì
	 * @param bonusPayNo„Ä?Âä?Áµ¶ÊôÇÈñì?Æ??
	 * @return„Ä?Âä?Áµ¶ÊôÇÈñì„É™„Çπ„É?
	 */
	private List<BonusPayTime> getByBonusPayNo(List<BonusPayTime> bonusPayTime,int bonusPayNo){
		return bonusPayTime.stream().filter(tc -> tc.getBonusPayTimeItemNo() == bonusPayNo).collect(Collectors.toList());
	}
	
	
	/**
	 * ÊéßÈô§ÊôÇÈñì„ÇíÂèñÂæ?
	 * @param dedClassification 
	 * @param dedAtr
	 * @param statutoryAtrs
	 * @param pertimesheet
	 * @return
	 */
	public TimeWithCalculation calcWithinTotalTime(ConditionAtr dedClassification, DeductionAtr dedAtr,StatutoryAtr statutoryAtr,TimeSheetRoundingAtr pertimesheet) {
		if(statutoryAtr.isStatutory()) {
			if(this.withinWorkingTimeSheet.isPresent()) {
				return TimeWithCalculation.sameTime(this.withinWorkingTimeSheet.get().calculationAllFrameDeductionTime(dedAtr, dedClassification));
			}
		}
		else if(statutoryAtr.isExcess()) {
			if(this.getOutsideWorkTimeSheet().isPresent()) {
				AttendanceTime overTime = this.getOutsideWorkTimeSheet().get().caluclationAllOverTimeFrameTime(dedAtr, dedClassification);
				AttendanceTime holidaytime = this.getOutsideWorkTimeSheet().get().caluclationAllHolidayFrameTime(dedAtr, dedClassification);
				return TimeWithCalculation.sameTime(overTime.addMinutes(holidaytime.valueAsMinutes()));
			}
		}
		return TimeWithCalculation.sameTime(new AttendanceTime(0));
	}

	 /**
	 * „Éï„É¨„É?ÇØ„Çπ„ÅÆÊôÇÈñìÂ∏Ø‰ΩúÊ?
	 * @param integrationOfDaily 
	 * @param integrationOfDaily 
	 */
	 public void createTimeSheetAsFlex(
			 		WorkingSystem workingSystem, PredetermineTimeSetForCalc predetermineTimeSetForCalc,
					BonusPaySetting bonusPaySetting,
					List<HDWorkTimeSheetSetting> fixOff,List<OverTimeOfTimeZoneSet> overTimeHourSetList,List<HolidayWorkFrameTimeSheet> holidayTimeWorkItem,  
					OverDayEndCalcSet dayEndSet,WorkType beforeDay, WorkType toDay, WorkType afterDay,
					BreakDownTimeDay breakdownTimeDay, DailyTime dailyTime, CalAttrOfDailyPerformance calcSetinIntegre,
					LegalOTSetting statutorySet, StatutoryPrioritySet prioritySet,
					WorkTimeSetting workTime,
					FlexWorkSetting flexWorkSetting,OutingTimeOfDailyPerformance outingTimeSheetofDaily,
					TimeSpanForCalc oneDayTimeSpan,TimeLeavingOfDailyPerformance attendanceLeaveWork,WorkTimeDivision workTimeDivision
					,List<BreakTimeOfDailyPerformance> breakTimeOfDailyList,MidNightTimeSheet midNightTimeSheet,DailyCalculationPersonalInformation personalInfo,
					HolidayCalcMethodSet holidayCalcMethodSet,Optional<CoreTimeSetting> coreTimeSetting,DailyUnit dailyUnit,List<TimeSheetOfDeductionItem> breakTimeList,
            		VacationClass vacationClass, TimevacationUseTimeOfDaily timevacationUseTimeOfDaily,
            		Optional<WorkTimeCode> siftCode, Optional<PersonalLaborCondition> personalCondition, 
            		boolean late, boolean leaveEarly, WorkDeformedLaborAdditionSet illegularAddSetting, WorkFlexAdditionSet flexAddSetting, 
            		WorkRegularAdditionSet regularAddSetting, HolidayAddtionSet holidayAddtionSet){
		 //if(!flexTimeSet.getUseFixedRestTime()){
			// predetermineTimeSetForCalc.correctPredetermineTimeSheet(dailyWork);
			 /*ÈÅ?àªÊó©ÈÄ?Âá¶Áê?*/
			// for() {
			//	 WithinWorkTimeSheet.createWorkingHourSet(workType,predetermineTimeSet,fixedWorkSetting);
				 /*ÈÅ?àªÊôÇÈñì„ÅÆË®àÁÆ?*/
				 /*Êó©ÈÄ?ÊôÇÈñì„ÅÆË®àÁÆ?*/
			// }
			 //WithinWorkTimeSheet.createWorkingHourSet(workType,predetermineTimeSetForCalc,fixedWorkSetting);
		 //}
		 //ÊéßÈô§ÊôÇÈñìÂ∏Ø„ÅÆ‰ΩúÊ?
		 val deductionTimeSheet = provisionalDeterminationOfDeductionTimeSheet(outingTimeSheetofDaily,
				 oneDayTimeSpan, attendanceLeaveWork, workTimeDivision,breakTimeOfDailyList,flexWorkSetting.getOffdayWorkTime().getRestTimezone(),flexWorkSetting.getRestSetting());
		 /*Âõ∫ÂÆöÂã§Âãô„?ÊôÇÈñìÂ∏Ø‰ΩúÊ?*/
		 val fixedWorkTimeZoneSet = new CommonFixedWorkTimezoneSet();
		 fixedWorkTimeZoneSet.forFlex(flexWorkSetting.getLstHalfDayWorkTimezone());
		 theDayOfWorkTimesLoop( workingSystem,  predetermineTimeSetForCalc,
				 	fixedWorkTimeZoneSet,  flexWorkSetting.getCommonSetting(),  bonusPaySetting,
					overTimeHourSetList,  fixOff,  dayEndSet,
					holidayTimeWorkItem,  beforeDay,  toDay,  afterDay,
					 breakdownTimeDay,  dailyTime,  calcSetinIntegre,
					 statutorySet,  prioritySet,
					 deductionTimeSheet,  workTime,midNightTimeSheet,personalInfo,holidayCalcMethodSet,coreTimeSetting,dailyUnit,breakTimeList,
					 vacationClass, timevacationUseTimeOfDaily, siftCode, 
					 personalCondition, leaveEarly, leaveEarly, illegularAddSetting, flexAddSetting, regularAddSetting, holidayAddtionSet);
		 /*„Ç≥„Ç¢„Çø„Ç§„É?„ÅÆ„Çª„É?Éà*/
		 //this.withinWorkingTimeSheet.set(withinWorkingTimeSheet.get().createWithinFlexTimeSheet(flexWorkSetting.getCoreTimeSetting()));
		 if(this.withinWorkingTimeSheet.isPresent())
			 this.withinWorkingTimeSheet = Finally.of(withinWorkingTimeSheet.get().createWithinFlexTimeSheet(flexWorkSetting.getCoreTimeSetting()));
	 }
	
//	 /**
//	 * ÊµÅÂãï‰ºëÊ?Áî®„ÅÆÊéßÈô§ÊôÇÈñìÂ∏Ø‰ΩúÊ?
//	 */
//	 public void createFluidBreakTime(DeductionAtr deductionAtr) {
//	 DeductionTimeSheet.createDedctionTimeSheet(acqAtr, setMethod,
//	 clockManage, dailyGoOutSheet, oneDayRange, CommonSet,
//	 attendanceLeaveWork, fixedCalc, workTimeDivision, noStampSet, fixedSet,
//	 breakTimeSheet);
//	
//	 }

	// ?äÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔºäÔº?
	//
	// /**
	// * ÊµÅÂãïÂã§Âãô„?ÊôÇÈñìÂ∏Ø‰ΩúÊ?
	// */
	// public void createFluidWork(
	// int workNo,
	// WorkTime workTime,
	// AttendanceLeavingWorkOfDaily attendanceLeavingWork,
	// DeductionTimeSheet deductionTimeSheet,
	// PredetermineTimeSet predetermineTimeSet,
	// WithinWorkTimeSheet withinWorkTimeSheet,
	// WithinWorkTimeFrame withinWorkTimeFrame,
	// HolidayWorkTimeSheet holidayWorkTimeSheet,
	// WorkType worktype) {
	// //Êâ?ÂÆöÊôÇÈñìË®≠ÂÆö„Çí„Ç≥„Éî„?„Åó„Å¶Ë®àÁÆóÁî®„ÅÆÊâ?ÂÆöÊôÇÈñìË®≠ÂÆö„Çí‰ΩúÊ?„Åô„Çã
	// this.predetermineTimeSetForCalc = new PredetermineTimeSetForCalc(
	// predetermineTimeSet.getAdditionSet(),
	// predetermineTimeSet.getSpecifiedTimeSheet().getTimeSheets(),
	// predetermineTimeSet.getSpecifiedTimeSheet().getAMEndTime(),
	// predetermineTimeSet.getSpecifiedTimeSheet().getPMStartTime());
	// //Âá∫ÈÄ?Âã§Âà?É´„Éº„É?
	// for(AttendanceLeavingWork attendanceLeavingWork :
	// attendanceLeavingWork.getAttendanceLeavingWork(workNo)) {
	// //‰∫ãÂâç„Å´ÈÅ?àªÊó©ÈÄ?„ÄÅÊéßÈô§ÊôÇÈñìÂ∏Ø„ÇíÂèñÂæó„Åô„Ç?
	// this.getForDeductionTimeSheetList(workNo, attendanceLeavingWork,
	// predetermineTimeSet, deductionTimeSheet ,workInformationOfDaily,
	// workType, withinWorkTimeFrame);
	// }
	// //„ÄåÂ?Âã§Á≥ª„Äç„Åã„Äå‰ºëÂ?Á≥ª„Äç„ÅãÂà§Êñ≠„Åô„Çã
	// boolean isWeekDayAttendance = worktype.isWeekDayAttendance();
	// //ÊôÇÈñì‰ºëÊöáÂä?ÁÆóÊÆãÊôÇÈñìÊú™Ââ≤ÂΩì‚?ÊôÇÈñì‰ºëÊöáÂä?ÁÆóÊÆãÊôÇÈñ?
	//
	// if(isWeekDayAttendance) {//Âá∫Âã§Á≥ª„ÅÆÂ†¥Âê?
	// //ÊµÅÂãïÂã§ÂãôÔºàÂ∞±ÂÜ??ÅÂπ≥Êó•??
	// WithinWorkTimeSheet newWithinWorkTimeSheet =
	// withinWorkTimeSheet.createAsFluidWork(predetermineTimeSetForCalc,
	// worktype, workInformationOfDaily, fluidWorkSetting, deductionTimeSheet);
	// //ÊµÅÂãïÂã§ÂãôÔºàÂ∞±Â§ñ„?ÅÂπ≥Êó•??
	//
	// }else{//‰ºëÂ?Á≥ª„ÅÆÂ†¥Âê?
	// //ÊµÅÂãïÂã§ÂãôÔºà‰ºëÊó•Âá∫Âã§??
	// HolidayWorkTimeSheet holidayWorkTimeSheet =
	// holidayWorkTimeSheet.createholidayWorkTimeSheet(attendanceLeavingWork,
	// workingTimes, deductionTimeSheet, worktype, holidayWorkTimeOfDaily,
	// calcRange);
	// }
	//
	//
	// }
	//
	// /**
	// * ‰∫ãÂâç„Å´ÈÅ?àªÊó©ÈÄ?„ÄÅÊéßÈô§ÊôÇÈñìÂ∏Ø„ÇíÂèñÂæó„Åô„Ç?
	// * @param workNo
	// * @param attendanceLeavingWork Âá∫ÈÄ?Âã§
	// * @return
	// */
	// public List<TimeSheetOfDeductionItem> getForDeductionTimeSheetList(
	// int workNo,
	// AttendanceLeavingWork attendanceLeavingWork,
	// PredetermineTimeSet predetermineTimeSet,
	// DeductionTimeSheet deductionTimeSheet,
	// WorkInformationOfDaily workInformationOfDaily,
	// WorkType workType,
	// WithinWorkTimeFrame withinWorkTimeFrame){
	//
	// //Êâ?ÂÆöÊôÇÈñìÂ∏Ø„ÇíÂèñÂæó„Åô„Ç?(ÊµÅÂãïË®àÁÆó„Åß‰ΩøÁî®„Åô„ÇãÊâ?ÂÆöÊôÇÈñì„?‰ΩúÊ?)
	// createPredetermineTimeSheetForFluid(workNo, predetermineTimeSet,
	// workType, workInformationOfDaily);
	// //Ë®àÁÆóÁØ?õ≤„ÇíÂà§Êñ≠„Åô„Çã
	// withinWorkTimeFrame.createWithinWorkTimeFrameForFluid(attendanceLeavingWork,
	// dailyWork, predetermineTimeSetForCalc);
	// //ÈÅ?àªÊôÇÈñìÂ∏Ø„ÇíÊéßÈô§
	// withinWorkTimeFrame.getLateTimeSheet().lateTimeCalcForFluid(withinWorkTimeFrame,
	// lateRangeForCalc, workTimeCommonSet, lateDecisionClock,
	// deductionTimeSheet);
	// //ÊéßÈô§ÊôÇÈñìÂ∏Ø„ÅÆ‰ªÆÁ¢∫ÂÆ?
	// this.provisionalDeterminationOfDeductionTimeSheet(deductionTimeSheet);
	// //Êó©ÈÄ?ÊôÇÈñìÂ∏Ø„ÇíÊéßÈô§
	//
	// //Âã§ÂãôÈñì„ÅÆ‰ºëÊ?Ë®≠ÂÆö„ÇíÂèñÂæ?
	//
	// }
	//
	// /**
	// * Ë®àÁÆóÁî®Êâ?ÂÆöÊôÇÈñìË®≠ÂÆö„Çí‰ΩúÊ?„Åô„Çã?àÊµÅÂãïÁî®??
	// * @return
	// */
	// public void createPredetermineTimeSheetForFluid(
	// int workNo,
	// PredetermineTimeSet predetermineTimeSet,
	// WorkType workType,
	// WorkInformationOfDaily workInformationOfDaily) {
	//
	// //‰∫àÂÆö„Å®ÂÆüÁ∏æ„ÅåÂêå„ÅòÂã§Âãô„Åã„Å©„Å?ÅãÁ¢∫Ë™?
	// if(workInformationOfDaily.isMatchWorkInfomation()/*‰∫àÂÆöÊôÇÈñìÂ∏Ø„Å´ÂÄ§„ÅåÂ?„Å£„Å¶„Å?Çã„Åã„?„ÉÅ„Çß„É?ÇØ„ÇíËøΩÂä?„Åô„ÇãÂø?¶Å„ÅÇ„Ç?*/)
	// {
	// //‰∫àÂÆöÊôÇÈñìÂ∏Ø„ÇíÂèñÂæó„Åô„Ç?
	// ScheduleTimeSheet scheduleTimeSheet =
	// workInformationOfDaily.getScheduleTimeSheet(workNo);
	// //Êâ?ÂÆöÊôÇÈñìÂ∏ØË®≠ÂÆö„?ÊôÇÈñìÂ∏Ø„ÇíÂ?„Å¶ÂèñÂæó„Åô„Ç?
	// List<TimeSheetWithUseAtr> timeSheetList =
	// predetermineTimeSet.getSpecifiedTimeSheet().getTimeSheets();
	// //Â§âÊõ¥ÂØæË±°„ÅÆÊôÇÈñìÂ∏Ø„ÇíÂèñÂæ?
	// List<TimeSheetWithUseAtr> list = timeSheetList.stream().filter(ts ->
	// ts.getCount()==workNo).collect(Collectors.toList());
	// TimeSheetWithUseAtr timeSheet = list.get(0);
	// //‰∫àÂÆöÊôÇÈñìÂ∏Ø„Å®Â§âÊõ¥ÂØæË±°„ÅÆÊôÇÈñìÂ∏Ø„ÇíÂü∫„Å´ÊôÇÈñìÂ∏Ø„Çí‰ΩúÊ?
	// TimeSheetWithUseAtr targetTimeSheet = new TimeSheetWithUseAtr(
	// timeSheet.getUseAtr(),
	// scheduleTimeSheet.getAttendance(),
	// scheduleTimeSheet.getLeaveWork(),
	// workNo);
	// //Â§âÊõ¥ÂØæË±°‰ª•Â§ñ„?ÊôÇÈñìÂ∏Ø„ÇíÂèñÂæ?
	// List<TimeSheetWithUseAtr> list2 = timeSheetList.stream().filter(ts ->
	// ts.getCount()!=workNo).collect(Collectors.toList());
	// TimeSheetWithUseAtr timeSheet2 = list2.get(0);
	//
	// List<TimeSheetWithUseAtr> newTimeSheetList =
	// Arrays.asList(targetTimeSheet,timeSheet2);
	//
	// this.predetermineTimeSetForCalc = new PredetermineTimeSetForCalc(
	// this.predetermineTimeSetForCalc.getAdditionSet(),
	// newTimeSheetList,
	// this.predetermineTimeSetForCalc.getAMEndTime(),
	// this.predetermineTimeSetForCalc.getPMStartTime());
	// }
	// //ÂçàÂâçÂã§Âãô„?ÅÂçàÂæåÂã§Âãô„?Â†¥Âêà„Å´ÊôÇÈñìÂ∏Ø„ÇíË£úÊ≠£„Åô„ÇãÂá¶Áê?
	// this.predetermineTimeSetForCalc.getPredetermineTimeSheet().correctPredetermineTimeSheet(workType.getDailyWork());
	// }
	//
	//
	 /**
	 * ÊéßÈô§ÊôÇÈñìÂ∏Ø„ÅÆ‰ªÆÁ¢∫ÂÆ?
	 */
	 public static DeductionTimeSheet provisionalDeterminationOfDeductionTimeSheet(OutingTimeOfDailyPerformance outingTimeSheetofDaily,
				TimeSpanForCalc oneDayTimeSpan,TimeLeavingOfDailyPerformance attendanceLeaveWork,WorkTimeDivision workTimeDivision
				,List<BreakTimeOfDailyPerformance> breakTimeOfDailyList,FlowWorkRestTimezone flowRestTimezone,FlowWorkRestSetting flowRestSetting) {
		 //ÊéßÈô§Áî®
		 val dedTimeSheet = DeductionTimeSheet.provisionalDecisionOfDeductionTimeSheet(DeductionAtr.Deduction, outingTimeSheetofDaily,
				 oneDayTimeSpan, attendanceLeaveWork, workTimeDivision,breakTimeOfDailyList,flowRestTimezone,flowRestSetting);
	 	 //Ë®à‰∏äÁî®
	 	 val recordTimeSheet = DeductionTimeSheet.provisionalDecisionOfDeductionTimeSheet(DeductionAtr.Appropriate, outingTimeSheetofDaily,
	 			 oneDayTimeSpan, attendanceLeaveWork, workTimeDivision,breakTimeOfDailyList,flowRestTimezone,flowRestSetting);
	 
	 	return new DeductionTimeSheet(dedTimeSheet,recordTimeSheet); 
	 }
	 
	 /**
	  * Â§ßÂ°ö„É¢„Éº„Éâ‰ΩøÁî®ÊôÇÂ∞ÇÁî®„ÅÆÈÅ?àª„ÄÅÊó©ÈÄ?ÂâäÈô§Âá¶Áê?
	  */
	 public void cleanLateLeaveEarlyTimeForOOtsuka() {
		 if(this.getWithinWorkingTimeSheet() != null
			&& this.getWithinWorkingTimeSheet().isPresent()){
			 this.withinWorkingTimeSheet.get().cleanLateLeaveEarlyTimeForOOtsuka();
		 }
	 }
	 
	 public void clearLeavingTime() {
		 this.attendanceLeavingWork = new TimeLeavingOfDailyPerformance(this.getAttendanceLeavingWork().getEmployeeId(), new WorkTimes(0), Collections.emptyList(), this.getAttendanceLeavingWork().getYmd());
	 }
	 
}
